Сюда будут записаны результаты компиляции разных вариантов вызовов функций.
Отличие вариантов следующее.
Есть 2 функции, выолняющие одно и то же, только параметры могут передаваться либо в развёрнутом виде (int x1, y1, x2, y2, ...), либо в виде указателей на структуры (struct rectangle *r).
При этом одна из функций вызывает другую.
Два варианта выпонения функций:
{1}. Основная функция работает с указателями на структуры, а дополнительная функция сначала упаковывет свои аргументы в структуру, а затем вызывает основную функцию с указателем на эту структуру.
Предполагается, что при работе основной функции тратится время и увеличивается размер кода, т.к. необходимо доставать аргументы из указателя на структуру.
{2}. Основная функция работает с развёрнутыми аргументами, а дополнительная вызывает основную, передав ей (развернув) аргументы из полей аказателя на структуру.
Предполагается, что это работает быстрее и занимает меньше места.

Вариантов вызова функций тоже 2:
{А}. Исходные параметры упаковываются с структуры, и вызывается функция с указателями на них.
{Б}. Исходные параметры (переменные) передаются в развернутом виде

То есть комбинации А1 и Б2 будут "родными" для передачи аргументов и работе с ними.

Вот в такой вот табличке будет отмечать хуже-лучше:

 А  |   |   |
 ---+---+---+ 
 Б  |   |   |
Где '+' значит лучше, а '-' значит хуже. Первая колонка - вариант 1, вторая - вариант 2.
 

Для проверки выбрана функция cdisp_triangle_fill из библиотеки cdisp.
Результаты компиляции разных комбинаций вариантов:
вар.  Размер debug / release
А1 -   18064 / 16096 (+44)                             А  |   |   |
А2 -   18016 / 16108 (+56)                             ---+---+---+ 
Б1 -   18116 / 16136 (+84) <- худший                   Б  | - | + |
Б2 -   17920 / 16052 ( 0 ) <- лучший
Если основная функция работает с указателями на структуры - получается средний вариант, и способ передачи аргументов слабо влияет на размер исходного кода.
Если основная функция работает с развёрнутым набором аргументов - то в зависимости от способа их передачи можно либо выиграть в размере кода (если способ совпадает), либо проиграть.

Проверка быстродействия - время рисования некольких (2240) маленьких треугольников. Собирается релиз с оптимизацией -O2 ("even more for speed").

вар.   мсек 
А1 - 1788 (+46) <- худший               А  | - | + |
А2 - 1742 ( 0 ) <- лучший               ---+---+---+ 
Б1 - 1747 ( +5)                         Б  | + | - |
Б2 - 1785 (+43)
Итог: неожиданный. Если используется функция-посредник - результат лучший. Если вызывается прямая функция (неважно, указатель на структуры или развёрнутые аргументы), то время выполнения увеличивается.

Посмотрим, что будет, если уменьшить кол-во вызовов и увеличить нагрузку внутри функции (работа с аргументами). Для этог сделаем ещё один тест быстродействия - с большими треугольниками (на сесь экран), 100 шт. (релиз -O2).
вар.   мсек 
А1 - 2461 (+101)                   А  | - | + |
А2 - 2360 ( 0 )  <- лучший         ---+---+---+ 
Б1 - 2361 ( +1)                    Б  | + | - |
Б2 - 2460 (+100)

Итог: как в предыдущем тесте. Ничего пока непонятно. Лучший в плане размера код выполняется дольше. Быстрее выполняется код, где аргументы претерпевают упаковку/распаковку - видимо, это связано с особенностями оптимизации компилятора.


Попробуем перенести тестовую процедуру в тот же модуль, где описаны вызываемые функции.
Условия те же - большие треугольники 100 шт. (релиз -O2).
вар.   мсек 
А1 - 2361                            А  | + | + |
А2 - 2360                            ---+---+---+ 
Б1 - 2361                            Б  | + | + |
Б2 - 2360

Итог: разницы между вариантами нет почти никакой, результаты совпадают с лучшими итогами предыдущего теста. Работа с аргументами, спрятанными за указатели на структуры, очень незначительно увеличивает время выполнения.
Компилятор, пользуясь тем, что всё находиится в одном модуле, максимально использует возможности оптимизации.

Попробуем сделать максимально быструю сборку - -O3, вызов функций внутри одного модуля.
Запишем и размер кода:

А1 - 19960 / 2261  ( +108 / +119)- большой/медленный - худший             А  | - | + |
А2 - 19852 / 2142 -( 0 / 0 ) маленький-быстрый - лучший                   ---+---+---+ 
Б1 - 19960 / 2261 - совп. с А1                                            Б  | - | + |
Б2 - 19852 / 2142 - совп. с А2
Здесь лучший - опять А2, а с ним и Б2: быстрее и лучше, когда внутри функции идет работа с развернутыми аргументами, а не с указателями. И неважно, в каком виде они передаются - в развёрнутом или упакованном, компилятор не сделает разницы.
В любом случае, даже самое худшее время выполнения лучше, чем при -O2.


Вызов процедур перенесём обратно в main, графическая нагрузка та же - большие треугольники 100 шт.
-O3 ("fully for speed"). Запишем также размер кода
А1 - 19912 / 2159 ( +48 /  +17)                       А  |   | + |
А2 - 19864 / 2142 (   0 /   0 )  <- лучший            ---+---+---+ 
Б1 - 19956 / 2261 ( +92 / +119)                       Б  | - | - |
Б2 - 19864 / 2243 (   0 / +101)

Итог: лучший вариант А - передача аргументов через указатель на структуру. Причём использование внутри функции развернутых аргументов даёт чуть лучший результат.


Оптимизация -Ofast.
А1 - 2159                                    А  |   | + |
А2 - 2142                                    ---+---+---+ 
Б1 - 2261                                    Б  | - | - |
Б2 - 2243
Результат совпадает с -O3, вероятно это тоже самое, что и -Ofast.


-Os (for size) Запишем размер кода / время выполнения
А1 - 17488 / 2607  ( +56 /   0 ) - средний-быстрый                     А  | + | - |
А2 - 17484 / 2708  ( +52 / 101 ) - средний-медленный                   ---+---+---+ 
Б1 - 17524 / 2607  ( +92 /   0 ) - большой-быстрый                     Б  | + | - |
Б2 - 17432 / 2709  (  0  / 102 ) - компактный-медленный
Чуть быстрее работает функция с аргументами в виде указателей на структуры. Объяснить я это не могу. Зато размер действительно минимальный.


Выводы.
Нелья однозначно сказать, какой вариант лучше. Ибо при изменении условий лучший вариант может превратится в худший.
Если есть возможность всё поместить в один модуль - лучше сделать так, и внутри функции работать с аргументами в явном виде, а не в видей полей из указателя на структуру.
Для получения максимального быстродействия использовать оптимизацию -Ofast, всё свести в один модуль, аргументы передавать в развёрнутом виде.


